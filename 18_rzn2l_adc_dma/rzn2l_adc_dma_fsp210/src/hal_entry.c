#include "hal_data.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event)
BSP_PLACE_IN_SECTION(".warm_start");
FSP_CPP_FOOTER

#define ENABLE_DMA      1
#define BUF_LEN         10

uint16_t adc_data[BUF_LEN] = {0};
uint16_t adc_dest0[BUF_LEN] = {0};
uint16_t adc_dest1[BUF_LEN] = {0};

static volatile uint32_t adc_end_flg = 0;
static volatile uint32_t dma_end_flg = 0;


/*******************************************************************************************************************//**
 * main() is generated by the FSP Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
#if defined(BSP_MCU_GROUP_RZN2H)
 #if (defined(BSP_CFG_CORE_CR52) && (0 == BSP_CFG_CORE_CR52))

    /* Set "1" to CA550_CTRL. */
    R_MPU_AC->CPU_CTRL |= 0x00000100;
 #endif
#endif

    memset(adc_data, 0, BUF_LEN * sizeof(uint16_t));
    memset(adc_dest0, 0, BUF_LEN * sizeof(uint16_t));
    memset(adc_dest1, 0, BUF_LEN * sizeof(uint16_t));

    __asm volatile ("cpsie i");

    // Must be before dma cfg!!!!!!!!!!!!
    g_adc103.p_api->open(g_adc103.p_ctrl, g_adc103.p_cfg);

#if ENABLE_DMA
    g_transfer0.p_api->open(g_transfer0.p_ctrl, g_transfer0.p_cfg);

    g_transfer0_ctrl.p_cfg->p_info->p_src = (void*)&g_adc103_ctrl.p_reg->ADDR[3];
    g_transfer0_ctrl.p_cfg->p_info->p_dest = (void*)&adc_dest0[0];
    g_transfer0_ctrl.p_cfg->p_info->length = sizeof(g_adc103_ctrl.p_reg->ADDR[3]) * BUF_LEN;
#if 1
    g_transfer0_ctrl.p_cfg->p_info->p_next1_src = (void*)&g_adc103_ctrl.p_reg->ADDR[3];
    g_transfer0_ctrl.p_cfg->p_info->p_next1_dest = (void*)&adc_dest1[0];
    g_transfer0_ctrl.p_cfg->p_info->next1_length = sizeof(g_adc103_ctrl.p_reg->ADDR[3]) * BUF_LEN;
#endif
    g_transfer0.p_api->reconfigure(g_transfer0.p_ctrl, g_transfer0_ctrl.p_cfg->p_info);

    //reconfigure auto enable dma
    //g_transfer0.p_api->enable(g_transfer0.p_ctrl);
    //g_transfer0.p_api->softwareStart(g_transfer0.p_ctrl, (transfer_start_mode_t)0);
#endif


    g_adc103.p_api->scanCfg(g_adc103.p_ctrl, g_adc103.p_channel_cfg);
    g_adc103.p_api->scanStart(g_adc103.p_ctrl);

    R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MILLISECONDS);

    while(1)
    {

#if (ENABLE_DMA != 1)
        /* Wait for conversion to complete. */
        while (0 >= adc_end_flg)
        {
            /* wait A/D conversion end */
        }
        adc_end_flg = 0;

        g_adc103.p_api->read(g_adc103.p_ctrl, ADC_CHANNEL_3, adc_data);
#endif
        R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MILLISECONDS);

        //running!

    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
        /* Pre clock initialization */
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

#if BSP_FEATURE_DDR_SUPPORTED
  #if (1 == BSP_CFG_DDR_INIT_ENABLE)

       /* Initialize the DDR settings. */
       bsp_ddr_init();
 #endif
#endif

        if (NULL != g_bsp_pin_cfg.p_extend)
        {
            /* Configure pins. */
            R_IOPORT_Open (&g_ioport_ctrl, &g_bsp_pin_cfg);
        }
    }
}
void adc_sample_callback(adc_callback_args_t * p_arg);
void adc_sample_callback(adc_callback_args_t * p_arg)
{
    (void)(p_arg);
    //for test, the callback should point NULL when FW be released
    adc_end_flg++;

    return;
}

void g_transfer0CB(transfer_callback_args_t *p_args);
void g_transfer0CB(transfer_callback_args_t *p_args)
{
	(void)(p_args);
    dma_end_flg++;

    //To perform transfers in series, write 1 to the REN bit in the CHCFG_n register immediately!!!
    //So you can't resume debugging from the pause!!!
    //p_instance_ctrl->p_reg->GRP[group].CH[channel].CHCFG_b.REN = 1;
    g_transfer0_ctrl.p_reg->GRP[0].CH[0].CHCFG_b.REN = 1;

    if(dma_end_flg == 1)
    {
        //todo:data parse

    }
    else if(dma_end_flg == 2)
    {
        dma_end_flg = 0;

        //todo:data parse

    }

    return;
}
